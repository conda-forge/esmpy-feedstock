diff -ruN -x __pycache__ -x obj -x '*~' -x tags -x TAGS -x '*.ESMF_LogFile' -x '*.egg-info' -x .pytest_cache -x .report.json -x 'esmpy*.test' -x build esmf-8.4.0.test/src/addon/esmpy/pyproject.toml esmf-8.4.0/src/addon/esmpy/pyproject.toml
--- esmf-8.4.0.test/src/addon/esmpy/pyproject.toml	2023-02-06 14:07:07.369242226 +0100
+++ esmf-8.4.0/src/addon/esmpy/pyproject.toml	2023-02-06 14:07:12.881277255 +0100
@@ -6,7 +6,7 @@
 name = "esmpy"
 description = "ESMF Python interface"
 # readme = "README.md"
-maintainers = [{author = "ESMF Core Team", email = "esmf_support@ucar.edu"}]
+maintainers = [{name = "ESMF Core Team", email = "esmf_support@ucar.edu"}]
 requires-python = ">=3.7"
 license = {text = "University of Illinois-NCSA"}
 dependencies = [
diff -ruN -x __pycache__ -x obj -x '*~' -x tags -x TAGS -x '*.ESMF_LogFile' -x '*.egg-info' -x .pytest_cache -x .report.json -x 'esmpy*.test' -x build esmf-8.4.0.test/src/addon/esmpy/src/esmpy/fragments/dump_esmf_internal_info.py esmf-8.4.0/src/addon/esmpy/src/esmpy/fragments/dump_esmf_internal_info.py
--- esmf-8.4.0.test/src/addon/esmpy/src/esmpy/fragments/dump_esmf_internal_info.py	2023-02-06 14:07:07.370242233 +0100
+++ esmf-8.4.0/src/addon/esmpy/src/esmpy/fragments/dump_esmf_internal_info.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +0,0 @@
-# This file contains old routines to dump internal ESMF info from ESMPy Grid and Field objects
-# This code is likely obsolete, but was useful in the original development process ..
-#    so it is being kept for a rainy day situation
-
-def dump_gridinfo(self, stagger):
-
-    [x,y,z] = [0,1,2]
-
-    print "bounds - low, high"
-    print self.lower_bounds[stagger], \
-                self.upper_bounds[stagger]
-    print "shape - [x, y, z] or [lat, lon]"
-    print self.coords[stagger][0].shape
-
-    if self.rank == 2:
-        return [self.coords[stagger][x], self.coords[stagger][y]]
-    elif self.rank == 3:
-        return [self.coords[stagger][x], self.coords[stagger][y], self.coords[stagger][z]]
-
-def dump_gridinfo_lower(self, stagger):
-    [x, y, z] = [0, 1, 2]
-
-    print "bounds - low, high"
-    print self.lower_bounds[stagger], \
-                self.upper_bounds[stagger]
-    print "shape - [x, y, z] or [lat, lon]"
-    print self.coords[stagger][0].shape
-
-    # retrieve buffers to esmf coordinate memory
-    gridptrX = self.get_grid_coords_from_esmc(x, stagger)
-    gridptrY = self.get_grid_coords_from_esmc(y, stagger)
-
-    #print esmf_coords
-    if self.rank == 2:
-        return [gridptrX, gridptrY]
-    elif self.rank == 3:
-        gridptrZ = self.get_grid_coords_from_esmc(z, stagger)
-        return [gridptrX, gridptrY, gridptrZ]
-
-def dump_gridinfo_ctypes(self, stagger, dim=2):
-
-    # find the size of the local coordinates at this stagger location
-    from operator import mul
-    size = reduce(mul,self.size[stagger])
-    [x, y, z] = [0, 1, 2]
-
-    # get the pointer to the underlying ESMF data array for coordinates
-
-    xptr = ESMP_GridGetCoordPtr(self, x, staggerloc=stagger)
-
-    import ctypes;
-    buffer_from_memory = ctypes.pythonapi.PyBuffer_FromMemory
-    buffer_from_memory.restype = ctypes.py_object
-    xbuffer = buffer_from_memory(xptr, int(8*size))
-    '''
-    xbuffer = np.core.multiarray.int_asbuffer(
-        ct.addressof(xptr.contents),
-        np.dtype(constants._ESMF2PythonType[self.type]).itemsize*size)
-    '''
-    xcoords = np.frombuffer(xbuffer, np.float64)
-    #xcoordarray = numpy.ndarray((nrows, ncols), dtype=numpy.float32, order='F',
-    #                 buffer=buf)
-
-    yptr = ESMP_GridGetCoordPtr(self, y, staggerloc=stagger)
-    ybuffer = np.core.multiarray.int_asbuffer(
-        ct.addressof(yptr.contents),
-        np.dtype(constants._ESMF2PythonType[self.type]).itemsize*size)
-    ycoords = np.frombuffer(ybuffer, constants._ESMF2PythonType[self.type])
-
-    print "DIAGNOSTICS:"
-    print "self.type = ", self.type
-    print "constants._ESMF2PythonType", constants._ESMF2PythonType[self.type]
-    print "constants._ESMF2PythonType.itemsize", constants._ESMF2PythonType[self.type].itemsize
-
-
-    # find the size of the local coordinates at this stagger location
-    from operator import mul
-    size = reduce(mul,self.size[stagger])
-
-    # these appear to both return bounds information only
-    lb, ub = ESMP_GridGetCoordBounds(self, staggerloc=stagger)
-
-    print "Bounds:"
-    print "  ESMPy.Grid:    ", size
-    print "  ESMPy.ctypes1: ", lb, ub
-
-
-    print "Coordinates:"
-    I = ub[x]-lb[x]
-    J = ub[y]-lb[y]
-    if dim == 3:
-        K = ub[z]-lb[z]
-
-    coordcount = 0
-    if dim == 2:
-        for i in range(I):
-            for j in range(J):
-                ind = i*J + j
-
-                if  (1e-10 > xcoords[ind] and xcoords[ind] != 0) or \
-                    xcoords[ind] > 360 or \
-                    -90 > ycoords[ind] or \
-                    (ycoords[ind] > -1e-10 and 1e-10 > ycoords[ind] and ycoords[ind] != 0) or \
-                    ycoords[ind] > 90:
-
-                    print "[", i, ", ", j, "] = [", xcoords[ind], ", ", ycoords[ind], "]"
-
-                coordcount += 1
-    elif dim == 3:
-        zptr = ESMP_GridGetCoordPtr(self, z, staggerloc=stagger)
-        zbuffer = np.core.multiarray.int_asbuffer(
-            ct.addressof(zptr.contents),
-            np.dtype(constants._ESMF2PythonType[self.type]).itemsize*size)
-        zcoords = np.frombuffer(zbuffer, constants._ESMF2PythonType[self.type])
-
-        for i in xrange(I):
-            for j in xrange(J):
-                for k in xrange(K):
-                    ind = i*I + j*J + k
-                    if  (1e-10 > xcoords[ind] and xcoords[ind] != 0) or \
-                        xcoords[ind] > 360 or \
-                        -90 > ycoords[ind] or \
-                        (ycoords[ind] > -1e-10 and 1e-10 > ycoords[ind] and ycoords[ind] != 0) or \
-                        ycoords[ind] > 90:
-
-                        print "[", i, ", ", j, "] = [", xcoords[ind], ", ", ycoords[ind], "]"
-                    coordcount += 1
-
-    print "Coordcount = ", coordcount
-    '''
-    # create a numpy array to point to the ESMF allocation
-    # reshape the numpy array of coordinates using Fortran ordering in Grid
-    gridCoordP = np.reshape(gridCoordP, self.size[stagger], order='F')
-    '''
-
-def _dump_field_coords_(self):
-    from operator import mul
-
-    # retrieve buffers to esmf coordinate memory
-    field_data = ESMP_FieldGetPtr(self.struct)
-
-    # find the reduced size of the coordinate arrays
-    size = reduce(mul,self.grid.size[self.staggerloc])
-
-    # loop through and alias esmf data to numpy arrays
-    buffer = np.core.multiarray.int_asbuffer(
-        ct.addressof(field_data.contents),
-        np.dtype(constants._ESMF2PythonType[self.type]).itemsize*size)
-    esmf_coords = np.frombuffer(buffer, constants._ESMF2PythonType[self.type])
-
-    print esmf_coords
diff -ruN -x __pycache__ -x obj -x '*~' -x tags -x TAGS -x '*.ESMF_LogFile' -x '*.egg-info' -x .pytest_cache -x .report.json -x 'esmpy*.test' -x build esmf-8.4.0.test/src/addon/esmpy/src/esmpy/fragments/extras.py esmf-8.4.0/src/addon/esmpy/src/esmpy/fragments/extras.py
--- esmf-8.4.0.test/src/addon/esmpy/src/esmpy/fragments/extras.py	2023-02-06 14:07:07.370242233 +0100
+++ esmf-8.4.0/src/addon/esmpy/src/esmpy/fragments/extras.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,191 +0,0 @@
-# $Id$
-
-"""
-utilities module - most of these routines are not yet implemented.
-"""
-
-#### IMPORT LIBRARIES #########################################################
-
-import ctypes as ct
-import numpy as np
-
-from constants import *
-from loadESMF import _ESMF
-
-#### CLASS DEFINITIONS ########################################################
-
-# shallow type 
-#class ESMP_ArraySpec(Structure):
-#    _fields_ = [("shallowMem", c_char*192)]
-#    _fields_ = [("shallowMem", create_string_buffer(192))]
-
-
-#### STATE ####################################################################
-
-_ESMF.ESMC_StateCreate.restype = c_void_p
-_ESMF.ESMC_StateCreate.argtypes = [c_char_p, POINTER(c_int)]
-def ESMP_StateCreate(name):
-    """
-    Preconditions: ESMP has been initialized.
-    Postconditions: An ESMP_State has been created.
-    Arguments:
-        RETURN ESMP_State :: state
-        string                        :: name
-    """
-    lrc = c_int(INIT)
-    state = _ESMF.ESMC_StateCreate(name,byref(lrc))
-    rc = lrc.value
-    if rc != _ESMP_SUCCESS:
-        raise NameError('ESMC_StateCreate() failed with rc = '+str(rc))
-    return state
-
-_ESMF.ESMC_StateDestroy.restype = c_int
-_ESMF.ESMC_StateDestroy.argtypes = [c_void_p]
-def ESMP_StateDestroy(state):
-    """
-    Preconditions: An ESMP_State has been created.
-    Postconditions: The 'state' has been destroyed.
-    Arguments:
-        ESMP_State :: state
-    """
-    ptr = POINTER(c_void_p)
-    stateptr = ptr(c_void_p(state))
-    rc = _ESMF.ESMC_StateDestroy(stateptr)
-    if rc != _ESMP_SUCCESS:
-        raise NameError('ESMC_StateDestroy() failed with rc = '+str(rc))
-    return
-
-_ESMF.ESMC_StatePrint.restype = c_int
-_ESMF.ESMC_StatePrint.argtypes = [c_void_p]
-def ESMP_StatePrint(state):
-    """
-    Preconditions: An ESMP_State has been created.
-    Postconditions: The contents of 'state' are printed to standard out.
-    Arguments:
-        ESMP_State :: state
-    """
-    rc = _ESMF.ESMC_StatePrint(state)
-    if rc != _ESMP_SUCCESS:
-        raise NameError('ESMC_StatePrint() failed with rc = '+str(rc))
-    return
-
-#### ARRAYSPEC ################################################################
-
-_ESMF.ESMC_ArraySpecGet.restype = c_int
-_ESMF.ESMC_ArraySpecGet.argtypes = [c_void_p, POINTER(c_int), POINTER(c_uint)]
-def ESMP_ArraySpecGet(arrayspec, rank, typekind):
-    '''
-    Preconditions: ESMP has been initialized and 'arrayspec' has been Set.
-    Postconditions: Information about 'arrayspec' has been returned in the form
-                    of a tuple containing: [rank, typekind].
-    Arguments:
-        RETURN integer       :: rank
-        RETURN TypeKind      :: typekind
-        type(ESMP_ArraySpec) :: arrayspec
-    '''
-    las = create_string_buffer(192)
-    las.value = arrayspec.shallowMem
-    lrank = c_int(INIT)
-    ltk = c_uint(INIT)
-    rc = _ESMF.ESMC_ArraySpecGet(las, byref(lrank), byref(ltk))
-    if rc != _ESMP_SUCCESS:
-        raise NameError('ESMC_ArraySpecGet() failed with rc = '+str(rc))
-    rank = lrank.value
-    typekind.tk = ltk.value
-    return rank, typekind
-
-_ESMF.ESMC_ArraySpecSet.restype = c_int
-_ESMF.ESMC_ArraySpecSet.argtypes = [c_void_p, c_int, c_uint]
-def ESMP_ArraySpecSet(arrayspec, rank, typekind):
-    '''
-    KNOWN BUG: This function is not yet implemented.
-    Preconditions: ESMP has been initialized
-    Postconditions: An ESMP_ArraySpec object has been setup.
-    Arguments:
-        RETURN ESMP_ArraySpec :: arrayspec
-        integer               :: rank
-        TypeKind              :: typekind
-    '''
-    las = create_string_buffer(192)
-    
-    rc = _ESMF.ESMC_ArraySpecSet(byref(las), rank, typekind.tk)
-    if rc != _ESMP_SUCCESS:
-        raise NameError('ESMC_ArraySpecSet() failed with rc = '+str(rc))
-    arrayspec.shallowMem = las.value
-    print 'sizeof(arrayspec) = '+str(sizeof(arrayspec))
-    print 'arrayspec = '+str(arrayspec)
-    print 'sizeof(las) = '+str(sizeof(las))
-    print 'las = '+str(las)
-    print "\n"
-    
-    return arrayspec
-
-#### MESH ################################################################
-
-_ESMF.ESMC_MeshVTKHeader.restype = c_int
-_ESMF.ESMC_MeshVTKHeader.argtypes = [c_char_p, POINTER(c_int), \
-                                     POINTER(c_int), POINTER(c_int)]
-def ESMP_MeshVTKHeader(fname, num_elem, num_node, conn_size):
-    """
-    KNOWN BUG: This function is not yet implemented.
-    Preconditions: An ESMP_Mesh has been created and 'fname' is a handle to a 
-                   valid (set of) vtk file(s).
-    Postconditions: The header information for 'fname' is returned in a tuple
-                    containing [num_elem, num_node, conn_size].
-    Arguments:
-        RETURN integer :: num_elem
-        RETURN integer :: num_node
-        RETURN integer :: conn_size
-        character      :: fname
-    """
-    nes = c_int(INIT)
-    nns = c_int(INIT)
-    cns = c_int(INIT)
-    rc = _ESMF.ESMC_MeshVTKHeader(c_char_p(fname), byref(nes), byref(nns), byref(cns))
-    if rc != _ESMP_SUCCESS:
-        raise NameError('ESMC_MeshVTKHeader() failed with rc = '+str(rc))
-    num_elem = nes.value
-    num_node = nns.value
-    conn_size = cns.value
-    return num_elem, num_node, conn_size
-    
-_ESMF.ESMC_MeshVTKBody.restype = c_int
-_ESMF.ESMC_MeshVTKBody.argtypes = [c_char_p, POINTER(c_int), \
-                                   POINTER(c_double), POINTER(c_int), \
-                                   POINTER(c_int), POINTER(c_int), \
-                                   POINTER(c_int)]
-def ESMP_MeshVTKBody(fname, nodeId, nodeCoord, nodeOwner,\
-                     elemId, elemType, elemConn):
-    """
-    KNOWN BUG: This function is not yet implemented.
-    Preconditions: An ESMP_Mesh has been created and 'fname' is a handle to a 
-                   valid (set of) vtk file(s).
-    Postconditions: The body information for 'fname' is returned in a tuple
-                    containing [nodeId, nodeCoord, nodeOwner, 
-                    elemId, elemType, elemConn].
-    Arguments:
-        RETURN integer :: nodeId
-        RETURN double  :: nodeCoord
-        RETURN integer :: nodeOwner
-        RETURN integer :: elemId
-        RETURN integer :: elemType
-        RETURN integer :: elemConn
-        character      :: fname
-    """
-    nis = c_int(INIT)
-    ncs = c_double(INIT)
-    nos = c_int(INIT)
-    eis = c_int(INIT)
-    ets = c_int(INIT)
-    ecs = c_int(INIT)
-    rc = _ESMF.ESMC_MeshVTKBody(fname, byref(nis), byref(ncs), byref(nos), \
-                                byref(eis), byref(ets), byref(ecs))
-    if rc != _ESMP_SUCCESS:
-        raise NameError('ESMC_MeshVTKBody() failed with rc = '+str(rc))
-    nodeId = nis.value
-    nodeCoord = ncs.value
-    nodeOwner = nos.value
-    elemId = eis.value
-    elemType = ets.value
-    elemConn = ecs.value
-    return nodeId, nodeCoord, nodeOwner, elemId, elemType, elemConn
diff -ruN -x __pycache__ -x obj -x '*~' -x tags -x TAGS -x '*.ESMF_LogFile' -x '*.egg-info' -x .pytest_cache -x .report.json -x 'esmpy*.test' -x build esmf-8.4.0.test/src/addon/esmpy/src/esmpy/fragments/remap.py esmf-8.4.0/src/addon/esmpy/src/esmpy/fragments/remap.py
--- esmf-8.4.0.test/src/addon/esmpy/src/esmpy/fragments/remap.py	2023-02-06 14:07:07.370242233 +0100
+++ esmf-8.4.0/src/addon/esmpy/src/esmpy/fragments/remap.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-# $Id$
-#===============================================================================
-#                                                        remap.py
-# 
-# This is a driver python script for the ESMF_RegridWeightGen application
-# CAUTION: this is extremely outdated
-#===============================================================================
-
-# ================================================================================
-# ================================================================================
-# 
-# Dependencies
-# ------------
-# 
-# 
-# 
-# ESMF must be built and installed for this python module to run properly.
-# If ESMF is not on your system you can download, build and install it by 
-# following the instructions in the "MORE HELP" section below.
-# 
-# The ESMF library must be built with NetCDF, and LAPACK support to enable
-# full functionality with this module.
-# 
-# If ESMF is already installed on the system you are using, you 
-# should only have to set the ESMFMKFILE environment variable.
-# This environment variable should be pointed to the esmf.mk file in the ESMF
-# installation.
-# 
-# The PYTHONPATH environment variable must also be set to the top-level
-# ESMP directory, then this module is accessed with: 
-# 
-#    from src import remap
-# 
-# ================================================================================
-# ================================================================================
-# 
-# Use
-# ---
-# 
-# There are three required input parameters to this python interface, and one 
-# optional parameter.    These are listed below, with descriptions and
-# default values if applicable:
-# 
-# srcgrid - The source grid, in NetCDF format, to be used in the remapping
-# weight generation.
-# 
-# dstgrid - The destination grid, in NetCDF format, to be used in the remapping
-# weight generation.
-# 
-# weights - The name of the NetCDF file into which the remapping weights will be
-# written.    
-# 
-# method - The interpolation method to be used to generate the weights.    The 
-# default method is "bilinear", other methods are "patch" and "conserve".    The
-# "patch" option specifies a patch recovery based finite element interpolation, 
-# and "conserve" specifies and area weighted first order locally conservative
-# method.
-# 
-# Some examples of how to use this interface are:
-# 
-# remap(source, destination, myweightsfile)
-# 
-# remap(source, destination, myweightsfile, conserve)
-# 
-# ================================================================================
-# ================================================================================
-# 
-# More Help
-# ------------
-# 
-# Details about the ESMF_RegridWeightGen application that is driven by the
-# interface can be found in the ESMF Reference Manual:
-# http://www.earthsystemmodeling.org/esmf_releases/public/ESMF_5_2_0r/ESMF_refdoc/node3.html
-# 
-# Information about the ESMF project can be found at the ESMF web site:
-#                     http://www.earthsystemmodeling.org
-#     
-# Software documentation for the last public release is at:
-#                     http://www.earthsystemmodeling.org -> Users -> Documentation
-#     
-# Software documentation for all releases is at:
-#                     http://www.earthsystemmodeling.org -> Download -> View All Releases
-#     
-# The ESMF library source code is also available for download at:
-#                     http://sourceforge.net/projects/esmf
-#     
-# Please contact esmf_support@ucar.edu with any questions or problems.
-#     
-# ================================================================================
-
-def remap(srcgrid, dstgrid, weights, method='bilinear'):
-    import os
-    import re
-    import sys
-        
-    # current running executable directory
-    RUNDIR = os.getcwd()
-    
-    #TODO is this in the esmf.mk?
-    # find out how many procs to use on this machine
-    if os.environ.get('ESMF_NUM_PROCS'):
-        NUM_PROCS = os.environ.get('ESMF_NUM_PROCS')
-    else:
-        print "ESMF_NUM_PROCS not defined in user environment, using default ESMF_NUM_PROCS=1"
-        NUM_PROCS = "1"
-    
-    # read the esmf.mk and get the location of the executable and the OS for 
-    # this system
-    if os.environ.get('ESMFMKFILE'):
-        esmfmkfile = open(os.environ.get('ESMFMKFILE'))
-    else:
-        print "ESMFMKFILE is not defined!"
-        sys.exit
-    
-    for line in esmfmkfile:
-        if re.search(".*ESMF_APPSDIR.*", line) != None:
-            ap_match = line 
-    
-    esmfmkfile.close()
-    
-    # clean up the executable name string for proper usage
-    ap_match = ap_match.split("=")[1]
-    APP = ap_match.strip()+"/ESMF_RegridWeightGen"
-    
-    # TODO: use 'bilinear' instead of 'b' for filename
-    # TODO: this could be a dict
-    options = ''
-    file = ''
-    # methods
-    if method == 'bilinear':
-        options = ''
-        file = 'b'
-    elif method == 'patch':
-        options = '-m patch'
-        file = 'p'
-    elif method == 'conserve':
-        options = '-m conserve'
-        file = 'c'
-    else:
-        print 'Method: '+method+' is not supported!'
-        sys.exit
-    
-    # TODO: what is this cruft?
-    #weights = weights.split('.')[0]
-    #weights = weights+"_"+file+".nc"
-    #srcgrid = "/export/shared/grids/ll1deg_grid.nc"
-    #dstgrid = "/export/shared/grids/ll2.5deg_grid.nc"
-    #options = ""
-    #weights = "srcgrid_to_dstgrid_b.nc"
-    
-    return os.system("mpirun -np "+NUM_PROCS+" "+APP+" "+options+\
-                     " -s "+srcgrid+" -d "+dstgrid+" -w "+weights+" > RegridWeightGen.out")
